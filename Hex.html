<html>

<head>
    <style>
        body {
            background: #333;
            text-align: center;
            margin: 40px auto 0;
        }
        
        .playable-canvas {
            border: 1px solid black;
            text-align: center;
        }
    </style>
</head>

<body>

    <canvas id="canvas" width="1600" height="1000" class="playable-canvas"></canvas>
	<canvas id="canvas2" width="600" height="600" class="playable-canvas"></canvas>
	<canvas id="canvas3" width="600" height="600" class="playable-canvas"></canvas>
	<canvas id="canvas4" width="600" height="600" class="playable-canvas"></canvas>

    <script>
		var geometryMaker = function (id) {	
			var canvas = document.getElementById(id),
				ctx = canvas.getContext("2d"),
				hexCosRatio = Math.cos(Math.PI / 6), // 
				hexSinRatio = Math.sin(Math.PI / 6), // 0.5!
				octCosRatio = Math.cos(Math.PI / 8), //
				octSinRatio = Math.sin(Math.PI / 8), //
				diagonals = {
					inner: function (i, j, tot) {
						var end = tot - 1,
								round = (!i || !j) && i + j === end;
						return !round && Math.abs(i - j) > 1;
					},
					everyTwo: function (i, j, tot) {;
						return (Math.abs(i - j + tot) % tot) === 2;
					},
					everyN: function (N) {
						return function (i, j, tot) {;
							return (Math.abs(i - j + tot) % tot) === N;
						}
					}
				},
				hash = function(num) { return ("" + num).substr(0, 6); },
				hexVertices = {
					midToTop: function(x, y, rad) { return { x: x, y: y - rad }; },
					topToTopR: function(x, y, rad) { return { x: x + rad * hexCosRatio, y: y + rad * hexSinRatio }; },
					topRToBotR: function(x, y, rad) { return { x: x, y: y + rad }; },
					botRToBot: function(x, y, rad) { return { x: x - rad * hexCosRatio, y: y + rad * hexSinRatio }; },
					botToBotL: function(x, y, rad) { return { x: x - rad * hexCosRatio, y: y - rad * hexSinRatio }; },
					botLToTopL: function(x, y, rad) { return { x: x, y: y - rad }; }
					//,topLTTop: function (x, y, rad) { return { x: x + rad * hexCosRatio, y: y - rad * hexSinRatio }; }
				},
				octVertices = {
					midToTopLeft: function(x, y, rad) { return { x: x - rad * octSinRatio, y: y - rad * octCosRatio }; },
					topLToTopR: function(x, y, rad) { return { x: x + rad * octSinRatio * 2, y: y }; },
					topRToRTop: function(x, y, rad) { 
						var mid = { x: x - rad * octSinRatio, y: y + rad * octCosRatio };
						return { x: mid.x + rad * octCosRatio, y: mid.y - rad * octSinRatio }; 
					},
					rTopToRBot: function(x, y, rad) { return { x: x, y: y + rad * octSinRatio * 2 }; },
					rBotToBotR: function(x, y, rad) { 
						var mid = { x: x - rad * octCosRatio, y: y - rad * octSinRatio };
						return { x: mid.x + rad * octSinRatio, y: mid.y + rad * octCosRatio }; 
					},
					botRToBotL: function(x, y, rad) { return { x: x - rad * octSinRatio * 2, y: y }; },
					botLToLBot: function(x, y, rad) { 
						var mid = { x: x + rad * octSinRatio, y: y - rad * octCosRatio };
						return { x: mid.x - rad * octCosRatio, y: mid.y + rad * octSinRatio }; 
					},
					lBotToLTop: function(x, y, rad) { return { x: x, y: y - rad * octSinRatio * 2 }; },
					//botLToTopL: function(x, y, rad) { return { x: x, y: y - rad }; }
					//,topLTTop: function (x, y, rad) { return { x: x + rad * hexCosRatio, y: y - rad * hexSinRatio }; }
				},
				penCache = {
					cache: {
						lines: {},
						circles: {},
						arches: {}
					},
					getPermission: function(x, y, rad, type, phi1, phi2) {
						var key = hash(x) + hash(y) + hash(rad),
							archKey = typeof(phi1) !== "undefined" ? key + hash(phi1) + hash(phi2) : "",
							result;

						if (this.cache[type][archKey || key]) {
							result = false;
						} else {
							this.cache[type][archKey || key] = true;
							result = true;
						}
						if (type === "arches" && this.cache.circles[key]) {
							result = false;
						}
						return result;
					}
				},
				boxes = [],
				addBox = function (title) {
					var boxMargin = 20,
						boxWidth = 240,
						boxHeight = 300,
						boxesPerRow = Math.floor(canvas.width / (boxWidth + boxMargin)),
						boxOffsetX = (boxes.length % boxesPerRow) * (boxMargin + boxWidth) + boxMargin,
						boxOffsetY = (boxMargin + boxHeight) * Math.floor(boxes.length / boxesPerRow) + boxMargin,
						boxMinPoint = { x: boxOffsetX + boxWidth/2, y: boxOffsetY + boxHeight/2 };

					ctx.rect(boxOffsetX, boxOffsetY, boxWidth, boxHeight);
					ctx.stroke();
					if (title) {
						ctx.textAlign = "center";
						ctx.font = "32px serif";
						ctx.strokeText(title, boxMinPoint.x, boxOffsetY + 30);
					}
					boxes.push(boxMinPoint);

					return boxMinPoint;
				},
				getMidPoint = function(x1, y1, x2, y2) {
					var result = {
						x: (x1 + x2) / 2,
						y: (y1 + y2) / 2
					};
					return result;
				},
				markMiddleSpot = function() {
					drawLine(0, canvas.height/2, 20, canvas.height/2);
					drawLine(canvas.height - 20, canvas.height/2, canvas.height, canvas.height/2);
					drawLine(canvas.width/2, 0, canvas.width/2, 20);
					drawLine(canvas.width/2, canvas.height - 20, canvas.width/2, canvas.height);
				},
				getArch = function(index) {
					return {
						phi1: Math.PI / 6 * ((index * 2) + 1),
						phi2: Math.PI / 6 * (((index * 2) + 5) % 12)
					}
				},
				makePolygon = function(instructions, centerX, centerY, radius) {
					var result = [],
						key,
						currentPoint = { x: centerX, y: centerY };

					for (key in instructions) {
						currentPoint = instructions[key](currentPoint.x, currentPoint.y, radius);
						result.push({
							x: currentPoint.x,
							y: currentPoint.y
						});
					}
					return result;
				},
				makeHex = function(centerX, centerY, radius) {
					return makePolygon(hexVertices, centerX, centerY, radius);
				},
				makeOct = function(centerX, centerY, radius) {
					return makePolygon(octVertices, centerX, centerY, radius);
				},			
				drawPolygon = function(polygon) {
					var i;

					ctx.moveTo(polygon[0].x, polygon[0].y);
					for (i = 1; i < polygon.length; i++) {
						ctx.lineTo(polygon[i].x, polygon[i].y);
					}
					ctx.closePath();
					ctx.stroke();
					return polygon;
				},
				makeGenericPolygon = function(c1, c2, radius, sides) {
					var i, result = [];

					result.push({ x: c1 + radius * Math.cos(0), y: c2 + radius * Math.sin(0) });

					for (var i = 1; i < sides;i += 1) {
						result.push({
							x: c1 + radius*Math.cos(2*Math.PI * i/sides),
							y: c2 + radius*Math.sin(2*Math.PI * i/sides)
						});
					}

					return result;
				},
				drawHex = function(centerX, centerY, radius) {
					return drawPolygon(makeHex(centerX, centerY, radius));
				},
				drawDiagonals = function(hex, rule) {
					var i, j;

					for (i = 0; i < hex.length; i++) {
						for (j = 0; j < hex.length; j++) {
							if (!rule || rule(i, j, hex.length)) {
								drawLine(hex[i].x, hex[i].y, hex[j].x, hex[j].y);
							}
						}
					}

				},
				drawOct = function (c1, c2, radius) {
					return drawPolygon(makeOct(c1, c2, radius));			
				},	
				drawLine = function(x1, y1, x2, y2) {
					ctx.moveTo(x1, y1);
					ctx.lineTo(x2, y2);
					ctx.stroke();
				},
				drawCircle = function(centerX, centerY, radius) {
					if (penCache.getPermission(centerX, centerY, radius, "circles")) {
						ctx.beginPath();
						ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
						ctx.stroke();
					}
				},
				drawTwoThirdsHexArc = function(centerX, centerY, radius, index) {
					var arch = getArch(index);

					if (penCache.getPermission(centerX, centerY, radius, "arches", arch.phi1, arch.phi2)) {
						ctx.beginPath();
						ctx.arc(centerX, centerY, radius, arch.phi1, arch.phi2);
						ctx.stroke();
					}
				},
				drawFlowerHex = function(c1, c2, radius, withHex, withCircle) {
					var myHex = (withHex ? drawHex : makeHex)(c1, c2, radius),
						i;

					if (withCircle) {
						drawCircle(c1, c2, radius);
					}
					for (i = 0; i < myHex.length; i++) {
						drawTwoThirdsHexArc(myHex[i].x, myHex[i].y, radius, i);
					}
					return myHex;
				},
				drawFlowerOct = function(c1, c2, radius, withCircle) {
					var c1 = canvas.width/2, c2 = canvas.height/2, radius = canvas.width/4,
					myOct = (1 ? drawOct : makeOct)(c1, c2, radius),
						i;

					if (withCircle) {
						drawCircle(c1, c2, radius);
					}
					for (i = 0; i < myOct.length; i++) {
						//drawTwoThirdsHexArc(myHex[i].x, myHex[i].y, radius, i);
						//drawFlowerHex(myOct[i].x, myOct[i].y, radius/2, 1);
					}
					
					drawDiagonals(myOct);
					return myOct;
				},
				drawFlowerOfLife = function() {
					var c1 = canvas.width/2, c2 = canvas.height/2, radius = canvas.width/4,
						myHex = makeHex(c1, c2, radius), i, midPoint,
						midHex = drawFlowerHex(c1, c2, radius / 2, 0, 1);

					for (i = 0; i < myHex.length; i++) {
						drawFlowerHex(myHex[i].x, myHex[i].y, radius / 2, 0, 1);

						drawFlowerHex(midHex[i].x, midHex[i].y, radius / 2);
						midPoint = getMidPoint(
								myHex[i].x,
								myHex[i].y,
								myHex[(i + 1) % myHex.length].x,
								myHex[(i + 1) % myHex.length].y);
						drawFlowerHex(midPoint.x, midPoint.y, radius / 2, 0, 1);
					}

					//drawCircle(c1, c2, radius);
					drawCircle(c1, c2, radius * 1.5);
				},
				drawMetatron = function() {
					var c1 = canvas.width/2, c2 = canvas.height/2, radius = canvas.width/3,
						myHex = drawHex(c1, c2, radius),
						i, midHex = drawHex(c1, c2, radius / 2);

					for (i = 0;i < myHex.length; i++) {
						drawCircle(myHex[i].x, myHex[i].y, radius/4);
						drawCircle(midHex[i].x, midHex[i].y, radius/4);
					}

					drawCircle(c1, c2, radius/4);
					drawDiagonals(myHex.concat(midHex));
				},
				drawTiledHex = function(full) {
					var c1 = canvas.width/2, c2 = canvas.height/2, radius = canvas.width/4,
						myHex = drawHex(c1, c2, radius),
						i, j, midMidHex, x1, y1;

					for (i = 0; i < myHex.length; i++) {
						x1 = myHex[i].x;
						y1 = myHex[i].y;
						midMidHex = drawFlowerHex(x1, y1, radius / 2, full);
						for (j = 0; j < midMidHex.length; j++) {
							drawFlowerHex(midMidHex[j].x, midMidHex[j].y, radius / 2, full);
						}
					}
					drawDiagonals(myHex);
					drawFlowerHex(c1, c2, radius / 2, full);
					drawDiagonals(drawHex(c1, c2, radius * 2))
				},
				layouts = {
					polygons: function() {
						var key, makeShapeFunc = function (sides, diagonality) {
								return function (title) {
									var box = addBox(title),
										polygon = makeGenericPolygon(box.x, box.y, 100, sides);
									drawPolygon(polygon);
									drawDiagonals(polygon, diagonals.everyN(diagonality));
								}
							},
							shapes = {
								"Rect": makeShapeFunc(4,2),
								"Pentagon": makeShapeFunc(5,2),
								"Hexagon": makeShapeFunc(6,2),
								"Heptagon": makeShapeFunc(7,2),
								"Octagon": makeShapeFunc(8,2),
								"Nonagon": makeShapeFunc(9,2),
								"Rect 3": makeShapeFunc(4,3),
								"Pentagon 3": makeShapeFunc(5,3),
								"Hexagon 3": makeShapeFunc(6,3),
								"Heptagon 3": makeShapeFunc(7,3),
								"Octagon 3": makeShapeFunc(8,3),
								"Nonagon 3": makeShapeFunc(9,3),
								"Rect 4": makeShapeFunc(4,4),
								"Pentagon 4": makeShapeFunc(5,4),
								"Hexagon 4": makeShapeFunc(6,4),
								"Heptagon 4": makeShapeFunc(7,4),
								"Octagon 4": makeShapeFunc(8,4),
								"Nonagon 4": makeShapeFunc(9,4),
							}

						for (key in shapes)
							shapes[key](key);

					},
					patterns: {
						metatron: drawMetatron,
						flowerOfLife: drawFlowerOfLife,
						tiledHex: drawTiledHex
					}
				};
				this.drawTiledHex = drawTiledHex;
				this.drawMetatron = drawMetatron;
				this.drawFlowerOfLife = drawFlowerOfLife;
				this.drawCrossedOct = drawFlowerOct;
				this.layouts = layouts;
			},
			canvas1 = new geometryMaker("canvas"),
			canvas2 = new geometryMaker("canvas2"),
			canvas3 = new geometryMaker("canvas3"),
			canvas4 = new geometryMaker("canvas4");

        //canvas1.drawMetatron();
        canvas1.layouts.polygons();
		canvas2.layouts.patterns.metatron();
		canvas3.layouts.patterns.flowerOfLife();
		canvas4.layouts.patterns.tiledHex();

    </script>
</body>

</html>