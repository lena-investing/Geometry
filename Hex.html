<html>

<head>
	<script src="jquery-3.1.1.js"></script>
    <style>
		ul { list-style-type: none; }
        label { cursor: pointer; }
		input[type=radio] { vertical-align: text-bottom; }
		input[type=checkbox] { vertical-align: sub; }
		label { line-height: 24px; }
		body {
			color: #EEE;
			font-size: 13px;
			font-family: Verdana;
            background: #333;
            text-align: center;
            margin: 40px auto 0;
        }
        
        .playable-canvas {
			border: 1px solid white;
            text-align: center;
        }

		.ui-wrapper {
			top: 50px;
			left: 60px;
			width: 440px;
			padding: 20px;
			padding-top: 5px;
			margin: 40px auto;
			position: absolute;
			border-radius: 8px;
			border: 1px solid white;
		}

		.ui-controls-wrapper {
			text-align: left;
		}

		.ui-controls-wrapper>div, .step2>div {
			margin: 10px 0;
		}

		.number-input {
			text-align: center;
			width: 80px;
		}

		.coords-wrapper, .tools-wrapper {
			text-align: center;
		}

		.coords-wrapper>div, .tools-wrapper>div {
			padding: 10px 10px;
		}

		.tools-oneRow>* {
			margin: 0 20px;
		}

		.hidden {
			display: none;
		}

		.bad {
			box-shadow: 0px 0px 7px 3px #e00f0f;
		}

    </style>
</head>
<body>
	<canvas id="canvas0" width="800" height="800" class="playable-canvas"></canvas>
	<div class="ui-wrapper">
		<div class="ui-title"><h3>Control Panel</h3></div>
		<div class="ui-controls-wrapper" id="ui-controls-wrapper">
			<div class="step-1">
				<div class="tools-wrapper">
					<div>
						Tools:
					</div>
					<div class="tools-oneRow">
						<label for="tools-markers">
							<input type="checkbox" id="tools-markers" /> Markers
						</label>
						<input type="button" class="tools-pushToStack" value="Save to Stack" />
						<input type="button" class="tools-clearStack" value="Clear Stack" />
					</div>
				</div>
				<div class="coords-wrapper">
					<div>
						<span class="coords-X-wrapper">
							X: <input type="text" class="coords-X number-input" value="400" />
						</span>
						<span class="coords-Y-wrapper">
							Y: <input type="text" class="coords-Y number-input" value="400" />
						</span>
					</div>
				</div>
				<ul>
					<label for="step1-radio1">
						<li>
							<input type="radio" id="step1-radio1" name="step1-radio" value="step1-radio1" class="step1-radio" />
							Polygon
						</li>
					</label>
					<label for="step1-radio2">
						<li>
							<input type="radio" id="step1-radio2" name="step1-radio" value="step1-radio2" class="step1-radio" />
							Spiral
						</li>
					</label>
					<label for="step1-radio3" class="hidden">
						<li>
							<input type="radio" id="step1-radio3" name="step1-radio" value="step1-radio3" class="step1-radio" />
							Pattern
						</li>
					</label>
				</ul>
			</div>
			<div class="step2">
				<div class="step2-polygon step2-section hidden">
					<span class="polygon-edges-wrapper">
						Number of edges: <input type="text" class="polygon-edges number-input" />
					</span>
					<span class="polygon-radius-wrapper">
						Radius: <input type="text" class="polygon-radius number-input" />
					</span>
				</div>
				<div class="step2-spiral step2-section hidden">
					<span class="spiral-ratio-wrapper">
						<div>
							<input type="radio" id="spiral-ratio-radio1" name="spiral-ratio-radio1" value="spiral-ratio-golden">
							<label for="spiral-ratio-radio1">Golden Ratio</label> (0.6180339887498949)
						</div>
						<div>
							<input type="radio" id="spiral-ratio-radio2" name="spiral-ratio-radio1" value="spiral-ratio-custom">
							<label for="spiral-ratio-radio2">Custom: </label>
							<input type="text" class="spiral-ratio-custom number-input" value="0.5"/>
						</div>
					</span>
				</div>
			</div>
		</div>
	</div>

    <script>

		var pi = Math.PI,
			phi = 2/(1 + Math.sqrt(5)),
			phiComp = 1-phi,
			geometryMaker = function (id) {
				var canvas = document.getElementById(id),
				ctx = canvas.getContext("2d"),
				textifyCoords = false,
				hexCosRatio = Math.cos(pi / 6), //
				hexSinRatio = Math.sin(pi / 6), // 0.5!
				octCosRatio = Math.cos(pi / 8), //
				octSinRatio = Math.sin(pi / 8), //
				diagonals = {
					inner: function (i, j, tot) {
						var end = tot - 1,
								round = (!i || !j) && i + j === end;
						return !round && Math.abs(i - j) > 1;
					},
					everyTwo: function (i, j, tot) {;
						return (Math.abs(i - j + tot) % tot) === 2;
					},
					everyN: function (N) {
						return function (i, j, tot) {;
							return (Math.abs(i - j + tot) % tot) === N;
						}
					}
				},
				hash = function(num) { return ("" + num).substr(0, 6); },
				hexVertices = {
					midToTop: function(x, y, rad) { return { x: x, y: y - rad }; },
					topToTopR: function(x, y, rad) { return { x: x + rad * hexCosRatio, y: y + rad * hexSinRatio }; },
					topRToBotR: function(x, y, rad) { return { x: x, y: y + rad }; },
					botRToBot: function(x, y, rad) { return { x: x - rad * hexCosRatio, y: y + rad * hexSinRatio }; },
					botToBotL: function(x, y, rad) { return { x: x - rad * hexCosRatio, y: y - rad * hexSinRatio }; },
					botLToTopL: function(x, y, rad) { return { x: x, y: y - rad }; }
					//,topLTTop: function (x, y, rad) { return { x: x + rad * hexCosRatio, y: y - rad * hexSinRatio }; }
				},
				octVertices = {
					midToTopLeft: function(x, y, rad) { return { x: x - rad * octSinRatio, y: y - rad * octCosRatio }; },
					topLToTopR: function(x, y, rad) { return { x: x + rad * octSinRatio * 2, y: y }; },
					topRToRTop: function(x, y, rad) { 
						var mid = { x: x - rad * octSinRatio, y: y + rad * octCosRatio };
						return { x: mid.x + rad * octCosRatio, y: mid.y - rad * octSinRatio }; 
					},
					rTopToRBot: function(x, y, rad) { return { x: x, y: y + rad * octSinRatio * 2 }; },
					rBotToBotR: function(x, y, rad) { 
						var mid = { x: x - rad * octCosRatio, y: y - rad * octSinRatio };
						return { x: mid.x + rad * octSinRatio, y: mid.y + rad * octCosRatio }; 
					},
					botRToBotL: function(x, y, rad) { return { x: x - rad * octSinRatio * 2, y: y }; },
					botLToLBot: function(x, y, rad) { 
						var mid = { x: x + rad * octSinRatio, y: y - rad * octCosRatio };
						return { x: mid.x - rad * octCosRatio, y: mid.y + rad * octSinRatio }; 
					},
					lBotToLTop: function(x, y, rad) { return { x: x, y: y - rad * octSinRatio * 2 }; },
					//botLToTopL: function(x, y, rad) { return { x: x, y: y - rad }; }
					//,topLTTop: function (x, y, rad) { return { x: x + rad * hexCosRatio, y: y - rad * hexSinRatio }; }
				},
				penCache = {
					cache: {
						lines: {},
						circles: {},
						arches: {}
					},
					getPermission: function(x, y, rad, type, phi1, phi2) {
						return true;

						// lol!!!!!
						var key = hash(x) + hash(y) + hash(rad),
							archKey = typeof(phi1) !== "undefined" ? key + hash(phi1) + hash(phi2) : "",
							result;

						if (this.cache[type][archKey || key]) {
							result = false;
						} else {
							this.cache[type][archKey || key] = true;
							result = true;
						}
						if (type === "arches" && this.cache.circles[key]) {
							result = false;
						}
						return result;
					}
				},
				boxes = [],
				clear = function () {
					ctx.clearRect(0, 0, canvas.width, canvas.height);
				}
				positivePiVal = function (angle) {
					return angle >= 0 ? angle : angle+2*pi;
				},
				softRound = function (num) {
					return Math.abs(num)<0.01 ? 0 : num;
				},
				strokeStyle = function (style) {
					ctx.strokeStyle = style;
				},
				addBox = function (title) {
					var boxMargin = 20,
						boxWidth = 240,
						boxHeight = 300,
						boxesPerRow = Math.floor(canvas.width / (boxWidth + boxMargin)),
						boxOffsetX = (boxes.length % boxesPerRow) * (boxMargin + boxWidth) + boxMargin,
						boxOffsetY = (boxMargin + boxHeight) * Math.floor(boxes.length / boxesPerRow) + boxMargin,
						boxMinPoint = { x: boxOffsetX + boxWidth/2, y: boxOffsetY + boxHeight/2 };

					ctx.rect(boxOffsetX, boxOffsetY, boxWidth, boxHeight);
					ctx.stroke();
					if (title) {
						ctx.textAlign = "center";
						ctx.font = "32px serif";
						ctx.strokeText(title, boxMinPoint.x, boxOffsetY + 30);
					}
					boxes.push(boxMinPoint);

					return boxMinPoint;
				},
				drawCustomSpiral = function () {
					drawSpiral(makeSpiral.apply(makeSpiral, arguments));
				},
				drawSpiral = function (set) {
					dotSet(set, true, true);
				},
				dotSet = function (set, byRad, partial) {
					var i, setArr = [].concat(set);

					for(i=0; i<setArr.length; i++) {
						drawCircle(
								setArr[i].x,
								setArr[i].y,
								byRad ? setArr[i].circleR : 3,
								partial ? setArr[i].phi1 : null,
								partial ? setArr[i].phi2 : null
						);
						if (textifyCoords) {
							ctx.textAlign = "center";
							ctx.font = "13px arial";
							ctx.strokeText("(" + parseInt(setArr[i].x) + ", " + parseInt(setArr[i].y) + ")", setArr[i].x, setArr[i].y - 20);
						}
					}
				},
				getMidPoint = function(x1, y1, x2, y2) {
					var result = {
						x: (x1 + x2) / 2,
						y: (y1 + y2) / 2
					};
					return result;
				},
				markMiddleSpot = function() {
					drawLine(0, canvas.height/2, 20, canvas.height/2);
					drawLine(canvas.height - 20, canvas.height/2, canvas.height, canvas.height/2);
					drawLine(canvas.width/2, 0, canvas.width/2, 20);
					drawLine(canvas.width/2, canvas.height - 20, canvas.width/2, canvas.height);
				},
				getArch = function(index) {
					return {
						phi1: pi / 6 * ((index * 2) + 1),
						phi2: pi / 6 * (((index * 2) + 5) % 12)
					}
				},
				makePolygon = function(instructions, centerX, centerY, radius) {
					var result = [],
						key,
						currentPoint = { x: centerX, y: centerY };

					for (key in instructions) {
						currentPoint = instructions[key](currentPoint.x, currentPoint.y, radius);
						result.push({
							x: currentPoint.x,
							y: currentPoint.y
						});
					}
					return result;
				},
				makeHex = function(centerX, centerY, radius) {
					return makePolygon(hexVertices, centerX, centerY, radius);
				},
				makeOct = function(centerX, centerY, radius) {
					return makePolygon(octVertices, centerX, centerY, radius);
				},			
				drawPolygon = function(polygon) {
					var i;

					ctx.beginPath();
					ctx.moveTo(polygon[0].x, polygon[0].y);
					for (i = 1; i < polygon.length; i++) {
						ctx.lineTo(polygon[i].x, polygon[i].y);
					}
					ctx.closePath();
					ctx.stroke();
					return polygon;
				},
				makeGenericPolygon = function(c1, c2, radius, sides) {
					var i, result = [];

					result.push({ x: c1 + radius * Math.cos(0), y: c2 + radius * Math.sin(0) });

					for (var i = 1; i < sides;i += 1) {
						result.push({
							x: c1 + radius*Math.cos(2*pi * i/sides),
							y: c2 + radius*Math.sin(2*pi * i/sides)
						});
					}

					return result;
				},
				drawHex = function(centerX, centerY, radius) {
					return drawPolygon(makeHex(centerX, centerY, radius));
				},
				drawDiagonals = function(hex, rule) {
					var i, j;

					for (i = 0; i < hex.length; i++) {
						for (j = 0; j < hex.length; j++) {
							if (!rule || rule(i, j, hex.length)) {
								drawLine(hex[i].x, hex[i].y, hex[j].x, hex[j].y);
							}
						}
					}

				},
				drawOct = function (c1, c2, radius) {
					return drawPolygon(makeOct(c1, c2, radius));			
				},	
				drawLine = function(x1, y1, x2, y2) {
					ctx.beginPath();
					ctx.moveTo(x1, y1);
					ctx.lineTo(x2, y2);
					ctx.stroke();
				},
				drawCircle = function(centerX, centerY, radius, phi1, phi2) {
					if (penCache.getPermission(centerX, centerY, radius, "circles")) {
						ctx.beginPath();
						ctx.arc(centerX, centerY, radius, positivePiVal(phi1 || 0), positivePiVal(phi2 || 2*pi));
						ctx.stroke();
					}
				},
				drawTwoThirdsHexArc = function(centerX, centerY, radius, index) {
					var arch = getArch(index);

					if (penCache.getPermission(centerX, centerY, radius, "arches", arch.phi1, arch.phi2)) {
						ctx.beginPath();
						ctx.arc(centerX, centerY, radius, arch.phi1, arch.phi2);
						ctx.stroke();
					}
				},
				drawFlowerHex = function(c1, c2, radius, withHex, withCircle) {
					var myHex = (withHex ? drawHex : makeHex)(c1, c2, radius),
						i;

					if (withCircle) {
						drawCircle(c1, c2, radius);
					}
					for (i = 0; i < myHex.length; i++) {
						drawTwoThirdsHexArc(myHex[i].x, myHex[i].y, radius, i);
					}
					return myHex;
				},
				drawFlowerOct = function(c1, c2, radius, withCircle) {
					var c1 = canvas.width/2, c2 = canvas.height/2, radius = canvas.width/4,
					myOct = (1 ? drawOct : makeOct)(c1, c2, radius),
						i;

					if (withCircle) {
						drawCircle(c1, c2, radius);
					}
					for (i = 0; i < myOct.length; i++) {
						//drawTwoThirdsHexArc(myHex[i].x, myHex[i].y, radius, i);
						//drawFlowerHex(myOct[i].x, myOct[i].y, radius/2, 1);
					}
					
					drawDiagonals(myOct);
					return myOct;
				},
				drawFlowerOfLife = function() {
					var c1 = canvas.width/2, c2 = canvas.height/2, radius = canvas.width/4,
						myHex = makeHex(c1, c2, radius), i, midPoint,
						midHex = drawFlowerHex(c1, c2, radius / 2, 0, 1);

					for (i = 0; i < myHex.length; i++) {
						drawFlowerHex(myHex[i].x, myHex[i].y, radius / 2, 0, 1);

						drawFlowerHex(midHex[i].x, midHex[i].y, radius / 2);
						midPoint = getMidPoint(
								myHex[i].x,
								myHex[i].y,
								myHex[(i + 1) % myHex.length].x,
								myHex[(i + 1) % myHex.length].y);
						drawFlowerHex(midPoint.x, midPoint.y, radius / 2, 0, 1);
					}

					//drawCircle(c1, c2, radius);
					drawCircle(c1, c2, radius * 1.5);
				},
				drawMetatron = function() {
					var c1 = canvas.width/2, c2 = canvas.height/2, radius = canvas.width/3,
						myHex = drawHex(c1, c2, radius),
						i, midHex = drawHex(c1, c2, radius / 2);

					for (i = 0;i < myHex.length; i++) {
						drawCircle(myHex[i].x, myHex[i].y, radius/4);
						drawCircle(midHex[i].x, midHex[i].y, radius/4);
					}

					drawCircle(c1, c2, radius/4);
					drawDiagonals(myHex.concat(midHex));
				},
				drawSpirals = function(sectionNumber, customRatio) {
					var i, spiral = makeSpiral(customRatio),
						midPoint = spiral[spiral.length-1], newSet,
						thetaOffset = 2*pi / sectionNumber;

					drawSpiral(spiral);

					for (i = 1; i < sectionNumber; i++) {
						newSet = spiral.map(function (point) {
							var pointPolar = convertToPolar(point, midPoint);

							pointPolar.theta -= softRound(thetaOffset*i);
							pointPolar.phi1 -= softRound(thetaOffset*i);
							pointPolar.phi2 -= softRound(thetaOffset*i);

							return polarToCartesian(pointPolar, midPoint);
						})
						drawSpiral(newSet);
					}

					markMiddleSpot();
				},
				makeSpiral = function(c1, c2, customPhi) {
					var i, newRad, radius = 500,
						phi1 = pi/2, phi2 = pi,
						result = [{
							x: c1,
							y: c2,
							circleR: radius,
							phi1: phi1,
							phi2: phi2
						}], rotation = [0, 1, 0, -1],
						myPhi = customPhi || phi;

					for (i=0; i<63; i++) {
						newRad = radius*(1 - myPhi);

						c1 = c1 + newRad*rotation[i%4];
						c2 = c2 + newRad*rotation[(i+1)%4];
						phi1 = (phi1 - (pi/2) + (2*pi)) % (2*pi);
						phi2 = (phi2 - (pi/2) + (2*pi)) % (2*pi);

						result.push({
							x: c1,
							y: c2,
							circleR: radius*myPhi,
							phi1: phi1,
							phi2: phi2
						});

						radius *= myPhi;
					}

					//dotSet(result);
					return result;
				},
				drawTiledHex = function(full) {
					var c1 = canvas.width/2, c2 = canvas.height/2, radius = canvas.width/4,
						myHex = drawHex(c1, c2, radius),
						i, j, midMidHex, x1, y1;

					for (i = 0; i < myHex.length; i++) {
						x1 = myHex[i].x;
						y1 = myHex[i].y;
						midMidHex = drawFlowerHex(x1, y1, radius / 2, full);
						for (j = 0; j < midMidHex.length; j++) {
							drawFlowerHex(midMidHex[j].x, midMidHex[j].y, radius / 2, full);
						}
					}
					drawDiagonals(myHex);
					drawFlowerHex(c1, c2, radius / 2, full);
					drawDiagonals(drawHex(c1, c2, radius * 2))
				},
				convertToPolar = function (point, relativeTo) {
					var toDeg = 180/pi,
						xDif = point.x - relativeTo.x,
						yDif = point.y - relativeTo.y,
						xNeg = xDif<0, yNeg = yDif<0,
						r = Math.sqrt(Math.pow(xDif, 2) + Math.pow(yDif, 2)),
						theta = xNeg ? Math.asin(yDif/r) : Math.acos(xDif/r),
						fullTheta = xNeg ? pi - theta : yNeg ? 2*pi - theta : theta;

//					drawCircle(relativeTo.x, relativeTo.y, Math.abs(r), fullTheta);
//					dotSet([point, relativeTo, {}]);
//					drawLine(point.x, point.y, relativeTo.x, relativeTo.y)

					return {
						r: r,
						theta: fullTheta || 0,
						circleR: point.circleR,
						phi1: point.phi1,
						phi2: point.phi2
					}
//					console.log(xDif, yDif);
//					//console.log(negX, yDif/r*negX, theta, fullTheta);
//					console.log(parseInt(theta*toDeg), parseInt(fullTheta*toDeg), (fThet % pi)*toDeg);
				},
				polarToCartesian = function (point, relativeTo) {
					var result = {
						x: relativeTo.x + point.r*Math.cos(point.theta),
						y: relativeTo.y + point.r*Math.sin(point.theta),
						circleR: point.circleR,
						phi1: point.phi1,
						phi2: point.phi2
					}
					return result;
				},
				layouts = {
					polygons: function(notRound) {
						var key, makeShapeFunc = function (sides, diagonality) {
								return function (title) {
									var box = addBox(title),
										polygon = makeGenericPolygon(box.x, box.y, 100, sides);

									if (notRound) {
										drawPolygon(polygon);
									} else {
										drawCircle(box.x, box.y, 100)
									}
									drawDiagonals(polygon, diagonals.everyN(diagonality));
								}
							},
							shapes = {
//								"Rect": makeShapeFunc(4,2),
//								"Pentagon": makeShapeFunc(5,2),
//								"Hexagon": makeShapeFunc(6,2),
//								"Heptagon": makeShapeFunc(7,2),
//								"Octagon": makeShapeFunc(8,2),
//								"Nonagon": makeShapeFunc(9,2),
//								"Rect 3": makeShapeFunc(4,3),
//								"Pentagon 3": makeShapeFunc(5,3),
//								"Hexagon 3": makeShapeFunc(6,3),
//								"Heptagon 3": makeShapeFunc(7,3),
//								"Octagon 3": makeShapeFunc(8,3),
//								"Nonagon 3": makeShapeFunc(9,3),
//								"Rect 4": makeShapeFunc(4,4),
//								"Pentagon 4": makeShapeFunc(5,4),
//								"Hexagon 4": makeShapeFunc(6,4),
//								"Heptagon 4": makeShapeFunc(7,4),
//								"Octagon 4": makeShapeFunc(8,4),
//								"Nonagon 4": makeShapeFunc(9,4),
//								"Rect 5": makeShapeFunc(4,5),
//								"Pentagon 5": makeShapeFunc(5,5),
//								"Hexagon 5": makeShapeFunc(6,5),
//								"Heptagon 5": makeShapeFunc(7,5),
//								"Octagon 5": makeShapeFunc(8,5),
//								"Nonagon 5": makeShapeFunc(9,5),
							}

						for (key in shapes)
							shapes[key](key);

					},
					patterns: {
						metatron: drawMetatron,
						flowerOfLife: drawFlowerOfLife,
						tiledHex: drawTiledHex,
						spiral: drawCustomSpiral,
						spirals: drawSpirals,
					}
				};
				this.drawTiledHex = drawTiledHex;
				this.drawMetatron = drawMetatron;
				this.drawFlowerOfLife = drawFlowerOfLife;
				this.drawCrossedOct = drawFlowerOct;
				this.spiral = drawCustomSpiral;
				this.clear = clear;
				this.markers = markMiddleSpot;

				this.polygon = function (c1, c2, r, edges) {
					var polygon = makeGenericPolygon(c1, c2, r, edges);
					drawPolygon(polygon);
				}

				this.layouts = layouts;
				ctx.strokeStyle = "#FFF";
			},
			ui = function () {
				var regi = {
						onlyNumbers: /^\d+$/,
						onlyNumbersWithFractions: /^\d+(\.\d+)?$/,
					},
					shapeStack = [],
					exportShapeStack = [],
					lsStack = localStorage.getItem('stack'),
					$controls = $('#ui-controls-wrapper'),
					$step1_tools = $controls.find('.tools-wrapper'),
					$step1_tools_pushToStack = $step1_tools.find('.tools-pushToStack'),
					$step1_tools_clearStack = $step1_tools.find('.tools-clearStack'),
					$step1_tools_markers = $step1_tools.find('#tools-markers'),
					$step1_coords = $controls.find('.coords-wrapper .coords-X, .coords-wrapper .coords-Y'),
					$step1_coordsX = $step1_coords.filter('.coords-X'),
					$step1_coordsY = $step1_coords.filter('.coords-Y'),
					$step1_radios = $controls.find("input[type=radio][name=step1-radio]"),
					$step1_radiosSpiral = $step1_radios.filter('#step1-radio2'),
					$step2 = $controls.find('.step2'),
					$step2_sections = $step2.find('.step2-section'),
					$step2_polygon_inputs = $step2.find('.step2-polygon input'),
					$step2_polygon_edges = $step2_polygon_inputs.filter('.polygon-edges'),
					$step2_polygon_radius = $step2_polygon_inputs.filter('.polygon-radius'),
					$step2_spiral_ratio = $step2.find('.spiral-ratio-wrapper'),
					$step2_spiral_radios = $step2_spiral_ratio.find('input[type=radio][name=spiral-ratio-radio1]'),
					$step2_spiral_radiosGolden = $step2_spiral_radios.filter('#spiral-ratio-radio1'),
					$step2_spiral_radiosCustom = $step2_spiral_radios.filter('#spiral-ratio-radio2'),
					$step2_spiral_ratioCustom = $step2_spiral_ratio.find('.spiral-ratio-custom'),
					ranges = {
						x: [0, 1000],
						y: [0, 1000],
						edges: [3, 20],
						radius: [1, 1000],
						ratio: [0.001, 0.9999]
					},
					isValid = {
						polygon: function () {
							var isValid = true,
								edges = $step2_polygon_edges.val(),
								radius = $step2_polygon_radius.val();

							if (!edges.match(regi.onlyNumbers) || +edges < ranges.edges[0] || +edges > ranges.edges[1]) {
								isValid = false;
								edges && $step2_polygon_edges.addClass('bad');
							} else {
								$step2_polygon_edges.removeClass('bad');
							}
							if (!radius.match(regi.onlyNumbers) || +radius < ranges.radius[0] || +radius > ranges.radius[1]) {
								isValid = false;
								radius && $step2_polygon_radius.addClass('bad');
							} else {
								$step2_polygon_radius.removeClass('bad');
							}

							return isValid;
						},
						spiral: function () {
							var isValid = false,
								customRatio = $step2_spiral_ratioCustom.val();

							if ($step2_spiral_radiosGolden.is(':checked')) {
								isValid = true;
							} else if ($step2_spiral_radiosCustom.is(':checked')) {
								if (!customRatio.match(regi.onlyNumbersWithFractions) || +customRatio < ranges.ratio[0] || +customRatio > ranges.ratio[1]) {
									customRatio && $step2_spiral_ratioCustom.addClass('bad');
								} else {
									isValid = true;
									customRatio && $step2_spiral_ratioCustom.removeClass('bad');
								}
							}

							return isValid;
						},
						coords: function () {
							var isValid = true, x = $step1_coordsX.val(), y = $step1_coordsY.val();

							if (!x.match(regi.onlyNumbers) || +x < ranges.x[0] || +x > ranges.x[1]) {
								isValid = false;
								x && $step1_coordsX.addClass('bad');
							} else {
								$step1_coordsX.removeClass('bad');
							}
							if (!y.match(regi.onlyNumbers) || +y < ranges.y[0] || +y > ranges.y[1]) {
								isValid = false;
								y && $step1_coordsY.addClass('bad');
							} else {
								$step1_coordsY.removeClass('bad');
							}

							return isValid;
						}
					},
					upDown = function (e, range, customIncrement) {
							var inc = customIncrement || 1,
								min = range[0], max = range[1];
							// UP and DOWN arrows
							switch (e.keyCode) {
								case 38:
									if (this.value.match(regi.onlyNumbersWithFractions) && (+this.value + inc) <= max) {
										this.value = roundLight(+this.value + inc);
									}
									break;
								case 40:
									if (this.value.match(regi.onlyNumbersWithFractions) && (+this.value - inc) >= min) {
										this.value = roundLight(+this.value - inc);
									}
									break;
							}
						},
					drawStack = function () {
						for (var i=0; i<shapeStack.length; i++) {
							shapeStack[i]();
						}
						if ($step1_tools_markers.is(':checked')) {
							mainCanvas.markers();
						}
					},
					updateStackIndication = function () {
						$step1_tools_pushToStack.val('Save to Stack (' + shapeStack.length + ')');
					},
					generatePolygon = function (e, store) {
						var edges, radius, x, y;
						setTimeout(function () {
							if (isValid.coords() && isValid.polygon()) {
								edges = +$step2_polygon_edges.val();
								radius = +$step2_polygon_radius.val();
								x = +$step1_coordsX.val();
								y = +$step1_coordsY.val();

								if (store) {
									shapeStack.push(mainCanvas.polygon.bind(mainCanvas, x, y, radius, edges));
									exportShapeStack.push(['polygon', x, y, radius, edges]);
									localStorage.setItem('stack', JSON.stringify(exportShapeStack))
									updateStackIndication();
								} else {
									mainCanvas.clear();
									drawStack();
									mainCanvas.polygon(x, y, radius, edges);
								}
							}
						}, 0)
					},
					storePolygon = generatePolygon.bind(null, null, true),
					generateSpiral = function (e, store) {
						var ratio, x, y;
						setTimeout(function () {
							if (e && $(e.target).is($step2_spiral_ratioCustom)) {
								upDown.apply(e.target, [e].concat(ranges.ratio));
							}

							if (isValid.coords() && isValid.spiral()) {
								if ($step2_spiral_radiosCustom.is(':checked')) {
									ratio = +$step2_spiral_ratioCustom.val();
								}
								x = +$step1_coordsX.val();
								y = +$step1_coordsY.val();

								if (store) {
									shapeStack.push(mainCanvas.spiral.bind(mainCanvas, x, y, ratio));
									exportShapeStack.push(['spiral', x, y, ratio]);
									localStorage.setItem('stack', JSON.stringify(exportShapeStack))
									updateStackIndication();
								} else {
									mainCanvas.clear();
									drawStack();
									mainCanvas.spiral(x, y, ratio);
								}
							}
						}, 0)
					},
					storeSpiral = generateSpiral.bind(null, null, true),
					roundLight = function (num) {
						var result = ("" + num).substr(0, 6);
						return +result;
					}
					functionifyExportStack = function () {
						shapeStack = exportShapeStack.map(function (shape) {
							var type = shape[0];							
							return mainCanvas[type].bind.apply(mainCanvas[type], [mainCanvas].concat(shape.slice(1)));
						})
					},
					makeUpDownFunction = function (range, customInc) {
						return function (e) {
							upDown.call(e.target, e, range, customInc);
						}
					};

				// Step 1 //
				// First step radios
				$step1_radios.change(function () {
					var actions = {
						"step1-radio1": $step2_sections.filter('.step2-polygon'),
						"step1-radio2": $step2_sections.filter('.step2-spiral')
					}

					$step2_sections._hide();

					actions[this.value]._show.call(actions[this.value]);
				});
				// Bind up/downs
				$step1_coords.on("keydown", makeUpDownFunction(ranges.x, 10)); // Use x's for both, separatable tho
				$step2_polygon_edges.on("keydown", makeUpDownFunction(ranges.edges));
				$step2_polygon_radius.on("keydown", makeUpDownFunction(ranges.radius, 10));
				$step2_spiral_ratioCustom.on("keydown", makeUpDownFunction(ranges.ratio, 0.05));

				// Step 2 //
				// Polygon Edges and Radius
				$step2_polygon_inputs.on("keydown", generatePolygon);

				// Golden or Custom Radios and Custom input
				$step2_spiral_radios.change(generateSpiral);
				$step2_spiral_ratioCustom.on("keydown", generateSpiral);

				// X and Y to also generate main shapes
				$step1_coords
						.on("keydown", generatePolygon)
						.on("keydown", generateSpiral);


				$step1_tools_markers.change(function () {
					if ($(this).is(':checked')) {
						mainCanvas.markers();
					} else {
						mainCanvas.clear();
					}
				})
				$step1_tools_pushToStack.click(function () {
					var selected = $step1_radios.filter(':checked').val(),
						actions = {
							"step1-radio1": storePolygon,
							"step1-radio2": storeSpiral
						}

					if (actions[selected]) {
						actions[selected]();
					}
				});
				$step1_tools_clearStack.click(function () {
					exportShapeStack = [];
					shapeStack = [];
					localStorage.setItem('stack', '');
					updateStackIndication();
					mainCanvas.clear();
				})

				if (lsStack) {
					exportShapeStack = JSON.parse(lsStack);
					functionifyExportStack();
					updateStackIndication();
					drawStack();
				}

				this.getJSON = function () {
					console.log(JSON.stringify(exportShapeStack));
				}
			},
			mainCanvas = new geometryMaker("canvas0"),
			uiInstance = new ui();

		$.fn._hide = function () {
			$(this).addClass('hidden');
		}
		$.fn._show = function () {
			$(this).removeClass('hidden');
		}

        //canvas1.drawMetatron();
		//mainCanvas.layouts.patterns.spirals(1);
//        canvas01.layouts.patterns.spirals(2);
//        canvas02.layouts.patterns.spirals(3);
//        canvas03.layouts.patterns.spirals(4);
//        canvas04.layouts.patterns.spirals(5);
//        canvas05.layouts.patterns.spirals(15);
//		canvas021.layouts.patterns.spirals(2, 0.2);
//		canvas022.layouts.patterns.spirals(3, 0.2);
//		canvas023.layouts.patterns.spirals(4, 0.2);
//		canvas024.layouts.patterns.spirals(5, 0.2);
//		canvas025.layouts.patterns.spirals(15, 0.2);
//        canvas00.layouts.patterns.spiral(0.89);
//        canvas1.layouts.polygons();
//        canvas11.layouts.polygons(true);
//		canvas2.layouts.patterns.metatron();
//		canvas3.layouts.patterns.flowerOfLife();
//		canvas4.layouts.patterns.tiledHex();

    </script>
</body>

</html>