<html>

<head>
	<script src="jquery-3.1.1.js"></script>
    <style>
		ul { list-style-type: none; display: inline-block; margin: 0; }
        label, input[type=checkbox], input[type=radio] { cursor: pointer; }
		input[type=radio] { vertical-align: text-bottom; }
		input[type=checkbox] { vertical-align: sub; }
		label { line-height: 24px; }
		button, input[type=button] {
			margin: 5px;
			color: white;
			font-size: 11px;
			cursor: pointer;
			padding: 4px 7px;
			border: 1px solid;
			border-radius: 3px;
			background: #2b2b2c;
		}
		.hidden {
			display: none;
		}

		.bad {
			box-shadow: 0px 0px 7px 3px #e00f0f;
		}

		.flexHor {
			display: flex;
			flex-direction: row;
		}

		.flex1 { flex: 1; }
		.flex2 { flex: 2; }
		body {
			color: #EEE;
			font-size: 13px;
			font-family: Verdana;
            background: #333;
            text-align: center;
            margin: 40px auto 0;
        }

		.verTop { vertical-align: top; }
		.marginTopS { margin-top: 4px; }
		.lineHeightM { line-height: 25px; }
		.textAlignLeft { text-align: left; }

        .playable-canvas {
			border: 1px solid white;
            text-align: center;
			border-radius: 3px;
        }

		.ui-wrapper {
			top: 0px;
			left: 60px;
			width: 440px;
			padding: 20px;
			padding-top: 5px;
			margin: 40px auto;
			position: absolute;
			border-radius: 3px;
			border: 1px solid white;
		}

		.ui-stack {
			right: 60px;
			left: initial;
		}

		.ui-controls-wrapper {
			text-align: left;
		}

		.ui-controls-wrapper>div, .step2>div {
			margin: 10px 0;
		}

		.number-input {
			width: 50px;
			border-radius: 3px;
			text-align: center;
		}

		.tools-rotator-angle {
			margin-left: 95px;
		}

		.polygon-edges-wrapper {
			padding: 0 0 12px;
		}

		.rotation-inner-wrapper {
			padding-left: 23px;
		}

		.rotation-axis-wrapper {
			padding: 10px 24px 0;
		}

		.coords-wrapper,
		.tools-wrapper,
		.step2-polygon {
			text-align: center;
		}

		.spiral-ratio-wrapper {
			width: 196px;
			margin: auto;
			text-align: left;
		}

		.coords-wrapper>div, .tools-wrapper>div {
			padding: 10px 10px;
		}

		.tools-oneRow>* {
			margin: 0 20px;
		}

		button.stack-delete {
			width: 16px;
			height: 16px;
			padding: 0px;
			margin: 0 10px;
			font-weight: bold;
		}

		.ui-stack-saveToLS {
		}
    </style>
</head>
<body>
	<canvas id="canvas0" width="800" height="800" class="playable-canvas"></canvas>
	<div class="ui-wrapper">
		<div class="ui-title"><h3>Control Panel</h3></div>
		<div class="ui-controls-wrapper" id="ui-controls-wrapper">
			<div class="step-1">
				<div class="coords-wrapper">
					<div>
						<span class="coords-X-wrapper">
							X: <input type="text" class="coords-X number-input" value="400" />
						</span>
						<span class="coords-Y-wrapper">
							Y: <input type="text" class="coords-Y number-input" value="400" />
						</span>
					</div>
				</div>
				<ul>
					<label for="step1-radio1">
						<li>
							<input type="radio" id="step1-radio1" name="step1-radio" value="step1-radio1" class="step1-radio" />
							Polygon
						</li>
					</label>
					<label for="step1-radio2">
						<li>
							<input type="radio" id="step1-radio2" name="step1-radio" value="step1-radio2" class="step1-radio" />
							Spiral
						</li>
					</label>
					<label for="step1-radio3" class="hidden">
						<li>
							<input type="radio" id="step1-radio3" name="step1-radio" value="step1-radio3" class="step1-radio" />
							Pattern
						</li>
					</label>
				</ul>
			</div>
			<div class="step2">
				<div class="step2-polygon step2-section hidden">
					<div class="polygon-edges-wrapper">
						Number of edges: <input type="text" class="polygon-edges number-input" />
					</div>
					<div class="polygon-radius-wrapper">
						Radius: <input type="text" class="polygon-radius number-input" value="200" />
					</div>
				</div>
				<div class="step2-spiral step2-section hidden">
					<div class="spiral-ratio-wrapper">
						<div>
							<label for="spiral-ratio-radio1">
								<input type="radio" id="spiral-ratio-radio1" name="spiral-ratio-radio1" value="spiral-ratio-golden">
								Golden Ratio (0.61803...)
							</label>
						</div>
						<div>
							<label for="spiral-ratio-radio2">
								<input type="radio" id="spiral-ratio-radio2" name="spiral-ratio-radio1" value="spiral-ratio-custom">
								Custom:
							</label>
							<input type="text" class="spiral-ratio-custom number-input" value="0.5"/>
						</div>
					</div>
				</div>
			</div>

			<div class="tools-wrapper">
				<div>
					Tools:
				</div>
				<div class="tools-oneRow">
					<label for="tools-markers">
						<input type="checkbox" id="tools-markers" /> Markers
					</label>
					<input type="button" class="tools-pushToStack" value="Save to Stack" />
				</div>
				<div class="rotation-wrapper textAlignLeft">
					<div class="rotation-inner-wrapper">
						<div>
							<label for="tools-rotator-checkbox">
								<input type="checkbox" id="tools-rotator-checkbox" /> Rotate
							</label>
							<span class="tools-rotator-angle hidden">
								Angle: <input type="text" class="rotator-angle number-input" value="0" />
							</span>
						</div>
						<div class="rotation-axis-wrapper hidden">
							<span class="verTop lineHeightM">
								Axis Point:
							</span>
							<span>
								<ul>
									<label for="tools-rotator-axisSMid">
										<li>
											<input type="radio" class="tools-rotator-mode-radios" name="tools-rotator-mode" id="tools-rotator-axisSMid" checked="checked" /> Shape Midpoint
										</li>
									</label>

									<label for="tools-rotator-axisCMid">
										<li>
											<input type="radio" class="tools-rotator-mode-radios" name="tools-rotator-mode" id="tools-rotator-axisCMid" /> Canvas Midpoint
										</li>
									</label>
									<li>
										<label for="tools-rotator-axisCustom">
											<input type="radio" class="tools-rotator-mode-radios" name="tools-rotator-mode" id="tools-rotator-axisCustom" /> Custom
										</label>
										X: <input type="text" class="tools-rotator-customAxisInput tools-rotator-customAxisInputX number-input" value="100" />
										Y: <input type="text" class="tools-rotator-customAxisInput tools-rotator-customAxisInputY number-input" value="100" />
									</li>
								</ul>
							</span>
						</div>
					</div>
				</div>
			</div>
		</div>
	</div>
	<div class="ui-wrapper ui-stack">
		<div class="ui-title"><h3>Stack Manager</h3></div>
		<div class="ui-stack-wrapper" id="ui-stack-wrapper">
			<div class="ui-stack-empty">Stack is empty</div>
			<div class="ui-stack-block-controls hidden">
				<button class="ui-stack-saveToLS">Save to LocalStorage</button>
				<input type="button" class="tools-clearStack" value="Clear Stack" />
			</div>
			<div class="export-wrapper hidden">
				<textarea id="export-output"></textarea>
			</div>
			<div class="ui-stack-block-wrapper hidden">
				<div class="ui-stack-block hidden"></div>
			</div>
		</div>
	</div>

    <script>

		var pi = Math.PI,
			phi = 2/(1 + Math.sqrt(5)),
			phiComp = 1-phi,
			geometryMaker = function (id) {
				var canvas = document.getElementById(id),
				ctx = canvas.getContext("2d"),
				textifyCoords = false,
				hexCosRatio = Math.cos(pi / 6), //
				hexSinRatio = Math.sin(pi / 6), // 0.5!
				octCosRatio = Math.cos(pi / 8), //
				octSinRatio = Math.sin(pi / 8), //
				diagonals = {
					inner: function (i, j, tot) {
						var end = tot - 1,
								round = (!i || !j) && i + j === end;
						return !round && Math.abs(i - j) > 1;
					},
					everyTwo: function (i, j, tot) {;
						return (Math.abs(i - j + tot) % tot) === 2;
					},
					everyN: function (N) {
						return function (i, j, tot) {;
							return (Math.abs(i - j + tot) % tot) === N;
						}
					}
				},
				hash = function(num) { return ("" + num).substr(0, 6); },
				hexVertices = {
					midToTop: function(x, y, rad) { return { x: x, y: y - rad }; },
					topToTopR: function(x, y, rad) { return { x: x + rad * hexCosRatio, y: y + rad * hexSinRatio }; },
					topRToBotR: function(x, y, rad) { return { x: x, y: y + rad }; },
					botRToBot: function(x, y, rad) { return { x: x - rad * hexCosRatio, y: y + rad * hexSinRatio }; },
					botToBotL: function(x, y, rad) { return { x: x - rad * hexCosRatio, y: y - rad * hexSinRatio }; },
					botLToTopL: function(x, y, rad) { return { x: x, y: y - rad }; }
				},
				octVertices = {
					midToTopLeft: function(x, y, rad) { return { x: x - rad * octSinRatio, y: y - rad * octCosRatio }; },
					topLToTopR: function(x, y, rad) { return { x: x + rad * octSinRatio * 2, y: y }; },
					topRToRTop: function(x, y, rad) { 
						var mid = { x: x - rad * octSinRatio, y: y + rad * octCosRatio };
						return { x: mid.x + rad * octCosRatio, y: mid.y - rad * octSinRatio }; 
					},
					rTopToRBot: function(x, y, rad) { return { x: x, y: y + rad * octSinRatio * 2 }; },
					rBotToBotR: function(x, y, rad) { 
						var mid = { x: x - rad * octCosRatio, y: y - rad * octSinRatio };
						return { x: mid.x + rad * octSinRatio, y: mid.y + rad * octCosRatio }; 
					},
					botRToBotL: function(x, y, rad) { return { x: x - rad * octSinRatio * 2, y: y }; },
					botLToLBot: function(x, y, rad) { 
						var mid = { x: x + rad * octSinRatio, y: y - rad * octCosRatio };
						return { x: mid.x - rad * octCosRatio, y: mid.y + rad * octSinRatio }; 
					},
					lBotToLTop: function(x, y, rad) { return { x: x, y: y - rad * octSinRatio * 2 }; }
				},
				penCache = {
					cache: {
						lines: {},
						circles: {},
						arches: {}
					},
					getPermission: function(x, y, rad, type, phi1, phi2) {

						return true;  // lol!!!!!

						var key = hash(x) + hash(y) + hash(rad),
							archKey = typeof(phi1) !== "undefined" ? key + hash(phi1) + hash(phi2) : "",
							result;

						if (this.cache[type][archKey || key]) {
							result = false;
						} else {
							this.cache[type][archKey || key] = true;
							result = true;
						}
						if (type === "arches" && this.cache.circles[key]) {
							result = false;
						}
						return result;
					}
				},
				boxes = [],
				clear = function () {
					ctx.clearRect(0, 0, canvas.width, canvas.height);
				}
				positivePiVal = function (angle) {
					return angle >= 0 ? angle : angle+2*pi;
				},
				softRound = function (num) {
					return Math.abs(num)<0.01 ? 0 : num;
				},
				strokeStyle = function (style) {
					ctx.strokeStyle = style;
				},
				addBox = function (title) {
					var boxMargin = 20,
						boxWidth = 240,
						boxHeight = 300,
						boxesPerRow = Math.floor(canvas.width / (boxWidth + boxMargin)),
						boxOffsetX = (boxes.length % boxesPerRow) * (boxMargin + boxWidth) + boxMargin,
						boxOffsetY = (boxMargin + boxHeight) * Math.floor(boxes.length / boxesPerRow) + boxMargin,
						boxMinPoint = { x: boxOffsetX + boxWidth/2, y: boxOffsetY + boxHeight/2 };

					ctx.rect(boxOffsetX, boxOffsetY, boxWidth, boxHeight);
					ctx.stroke();
					if (title) {
						ctx.textAlign = "center";
						ctx.font = "32px serif";
						ctx.strokeText(title, boxMinPoint.x, boxOffsetY + 30);
					}
					boxes.push(boxMinPoint);

					return boxMinPoint;
				},
				drawCustomSpiral = function (x, y, ratio, rotation) {
					var spiral = makeSpiral(x, y, ratio);

					if (rotation.rotate) {
						spiral = rotateSet(spiral, rotation.axisPoint, rotation.theta);
					}

					drawSpiral(spiral);
				},
				drawCustomPolygon = function (c1, c2, r, edges, rotation) {
					var polygon = makeGenericPolygon(c1, c2, r, edges);

					if (rotation.rotate) {
						polygon = rotateSet(polygon, rotation.axisPoint, rotation.theta);
					}

					drawPolygon(polygon);
				},
				drawSpiral = function (set) {
					dotSet(set, true, true);
				},
				dotSet = function (set, byRad, partial) {
					var i, setArr = [].concat(set);

					for(i=0; i<setArr.length; i++) {
						drawCircle(
								setArr[i].x,
								setArr[i].y,
								byRad ? setArr[i].circleR : 3,
								partial ? setArr[i].phi1 : null,
								partial ? setArr[i].phi2 : null
						);
						if (textifyCoords) {
							ctx.textAlign = "center";
							ctx.font = "13px arial";
							ctx.strokeText("(" + parseInt(setArr[i].x) + ", " + parseInt(setArr[i].y) + ")", setArr[i].x, setArr[i].y - 20);
						}
					}
				},
				getMidPoint = function(x1, y1, x2, y2) {
					var result = {
						x: (x1 + x2) / 2,
						y: (y1 + y2) / 2
					};
					return result;
				},
				markMiddleSpot = function() {
					drawLine(0, canvas.height/2, 20, canvas.height/2);
					drawLine(canvas.height - 20, canvas.height/2, canvas.height, canvas.height/2);
					drawLine(canvas.width/2, 0, canvas.width/2, 20);
					drawLine(canvas.width/2, canvas.height - 20, canvas.width/2, canvas.height);
				},
				getArch = function(index) {
					return {
						phi1: pi / 6 * ((index * 2) + 1),
						phi2: pi / 6 * (((index * 2) + 5) % 12)
					}
				},
				makePolygon = function(instructions, centerX, centerY, radius) {
					var result = [],
						key,
						currentPoint = { x: centerX, y: centerY };

					for (key in instructions) {
						currentPoint = instructions[key](currentPoint.x, currentPoint.y, radius);
						result.push({
							x: currentPoint.x,
							y: currentPoint.y
						});
					}
					return result;
				},
				makeHex = function(centerX, centerY, radius) {
					return makePolygon(hexVertices, centerX, centerY, radius);
				},
				makeOct = function(centerX, centerY, radius) {
					return makePolygon(octVertices, centerX, centerY, radius);
				},			
				drawPolygon = function(polygon) {
					var i;

					ctx.beginPath();
					ctx.moveTo(polygon[0].x, polygon[0].y);
					for (i = 1; i < polygon.length; i++) {
						ctx.lineTo(polygon[i].x, polygon[i].y);
					}
					ctx.closePath();
					ctx.stroke();
					return polygon;
				},
				makeGenericPolygon = function(c1, c2, radius, sides) {
					var i, result = [];

					result.push({ x: c1 + radius * Math.cos(0), y: c2 + radius * Math.sin(0) });

					for (var i = 1; i < sides;i += 1) {
						result.push({
							x: c1 + radius*Math.cos(2*pi * i/sides),
							y: c2 + radius*Math.sin(2*pi * i/sides)
						});
					}

					return result;
				},
				drawHex = function(centerX, centerY, radius) {
					return drawPolygon(makeHex(centerX, centerY, radius));
				},
				drawDiagonals = function(hex, rule) {
					var i, j;

					for (i = 0; i < hex.length; i++) {
						for (j = 0; j < hex.length; j++) {
							if (!rule || rule(i, j, hex.length)) {
								drawLine(hex[i].x, hex[i].y, hex[j].x, hex[j].y);
							}
						}
					}

				},
				drawOct = function (c1, c2, radius) {
					return drawPolygon(makeOct(c1, c2, radius));			
				},	
				drawLine = function(x1, y1, x2, y2) {
					ctx.beginPath();
					ctx.moveTo(x1, y1);
					ctx.lineTo(x2, y2);
					ctx.stroke();
				},
				drawCircle = function(centerX, centerY, radius, phi1, phi2) {
					if (penCache.getPermission(centerX, centerY, radius, "circles")) {
						ctx.beginPath();
						ctx.arc(centerX, centerY, radius, positivePiVal(phi1 || 0), positivePiVal(phi2 || 2*pi));
						ctx.stroke();
					}
				},
				drawTwoThirdsHexArc = function(centerX, centerY, radius, index) {
					var arch = getArch(index);

					if (penCache.getPermission(centerX, centerY, radius, "arches", arch.phi1, arch.phi2)) {
						ctx.beginPath();
						ctx.arc(centerX, centerY, radius, arch.phi1, arch.phi2);
						ctx.stroke();
					}
				},
				drawFlowerHex = function(c1, c2, radius, withHex, withCircle) {
					var myHex = (withHex ? drawHex : makeHex)(c1, c2, radius),
						i;

					if (withCircle) {
						drawCircle(c1, c2, radius);
					}
					for (i = 0; i < myHex.length; i++) {
						drawTwoThirdsHexArc(myHex[i].x, myHex[i].y, radius, i);
					}
					return myHex;
				},
				drawFlowerOct = function(c1, c2, radius, withCircle) {
					var c1 = canvas.width/2, c2 = canvas.height/2, radius = canvas.width/4,
					myOct = (1 ? drawOct : makeOct)(c1, c2, radius),
						i;

					if (withCircle) {
						drawCircle(c1, c2, radius);
					}
					for (i = 0; i < myOct.length; i++) {
						//drawTwoThirdsHexArc(myHex[i].x, myHex[i].y, radius, i);
						//drawFlowerHex(myOct[i].x, myOct[i].y, radius/2, 1);
					}
					
					drawDiagonals(myOct);
					return myOct;
				},
				drawFlowerOfLife = function() {
					var c1 = canvas.width/2, c2 = canvas.height/2, radius = canvas.width/4,
						myHex = makeHex(c1, c2, radius), i, midPoint,
						midHex = drawFlowerHex(c1, c2, radius / 2, 0, 1);

					for (i = 0; i < myHex.length; i++) {
						drawFlowerHex(myHex[i].x, myHex[i].y, radius / 2, 0, 1);

						drawFlowerHex(midHex[i].x, midHex[i].y, radius / 2);
						midPoint = getMidPoint(
								myHex[i].x,
								myHex[i].y,
								myHex[(i + 1) % myHex.length].x,
								myHex[(i + 1) % myHex.length].y);
						drawFlowerHex(midPoint.x, midPoint.y, radius / 2, 0, 1);
					}

					//drawCircle(c1, c2, radius);
					drawCircle(c1, c2, radius * 1.5);
				},
				drawMetatron = function() {
					var c1 = canvas.width/2, c2 = canvas.height/2, radius = canvas.width/3,
						myHex = drawHex(c1, c2, radius),
						i, midHex = drawHex(c1, c2, radius / 2);

					for (i = 0;i < myHex.length; i++) {
						drawCircle(myHex[i].x, myHex[i].y, radius/4);
						drawCircle(midHex[i].x, midHex[i].y, radius/4);
					}

					drawCircle(c1, c2, radius/4);
					drawDiagonals(myHex.concat(midHex));
				},
				drawSpirals = function(sectionNumber, customRatio) {
					var i, spiral = makeSpiral(customRatio),
						midPoint = spiral[spiral.length-1], newSet,
						thetaOffset = 2*pi / sectionNumber;

					drawSpiral(spiral);

					for (i = 1; i < sectionNumber; i++) {
						newSet = rotateSet(spiral, midPoint, thetaOffset*i);
						drawSpiral(newSet);
					}

					markMiddleSpot();
				},
				makeSpiral = function(c1, c2, customPhi) {
					var i, newRad, radius = 500,
						phi1 = pi/2, phi2 = pi,
						result = [{
							x: c1,
							y: c2,
							circleR: radius,
							phi1: phi1,
							phi2: phi2
						}], rotation = [0, 1, 0, -1],
						myPhi = customPhi || phi,
						strength = 20;

					if (customPhi > 0.75) {
						strength = 60;
						if (customPhi > 0.9) {
							strength = 160;
							if (customPhi > 0.95) {  //             Rewrite elegantly!
								strength = 460;
								if (customPhi > 0.98) {
									strength = 1100;
									if (customPhi > 0.997) {
										strength = 4600;
									}
								}
							}
						}
					} console.log("Iteration Stength", strength);
					// < 0.75: 23, <0.9: 60, <0.97:160....???????


					for (i=0; i<strength; i++) {
						newRad = radius*(1 - myPhi);

						c1 = c1 + newRad*rotation[i%4];
						c2 = c2 + newRad*rotation[(i+1)%4];
						phi1 = (phi1 - (pi/2) + (2*pi)) % (2*pi);
						phi2 = (phi2 - (pi/2) + (2*pi)) % (2*pi);

						result.push({
							x: c1,
							y: c2,
							circleR: radius*myPhi,
							phi1: phi1,
							phi2: phi2
						});

						radius *= myPhi;
					}

					//dotSet(result);
					return result;
				},
				drawTiledHex = function(full) {
					var c1 = canvas.width/2, c2 = canvas.height/2, radius = canvas.width/4,
						myHex = drawHex(c1, c2, radius),
						i, j, midMidHex, x1, y1;

					for (i = 0; i < myHex.length; i++) {
						x1 = myHex[i].x;
						y1 = myHex[i].y;
						midMidHex = drawFlowerHex(x1, y1, radius / 2, full);
						for (j = 0; j < midMidHex.length; j++) {
							drawFlowerHex(midMidHex[j].x, midMidHex[j].y, radius / 2, full);
						}
					}
					drawDiagonals(myHex);
					drawFlowerHex(c1, c2, radius / 2, full);
					drawDiagonals(drawHex(c1, c2, radius * 2))
				},
				rotateSet = function (set, axisPoint, thetaOffset) {
					var pointPolar, roundedTheta, madeAxisPoint, setEnd = set[set.length-1];
					if (axisPoint.x === null || axisPoint.y === null) { // If either is set to null, meaning a spiral rotating around his midpoint (unknown before drawn)
						madeAxisPoint = {
							x: setEnd.x,
							y: setEnd.y
						}
					}
					return set.map(function (point) {
						roundedTheta = softRound(thetaOffset);
						pointPolar = convertToPolar(point, madeAxisPoint || axisPoint);

						pointPolar.theta -= roundedTheta;
						pointPolar.phi1 -= roundedTheta;
						pointPolar.phi2 -= roundedTheta;

						return polarToCartesian(pointPolar, madeAxisPoint || axisPoint);
					})
				},
				convertToPolar = function (point, relativeTo) {
					var toDeg = 180/pi,
						xDif = point.x - relativeTo.x,
						yDif = point.y - relativeTo.y,
						xNeg = xDif<0, yNeg = yDif<0,
						r = Math.sqrt(Math.pow(xDif, 2) + Math.pow(yDif, 2)),
						theta = xNeg ? Math.asin(yDif/r) : Math.acos(xDif/r),
						fullTheta = xNeg ? pi - theta : yNeg ? 2*pi - theta : theta;

//					drawCircle(relativeTo.x, relativeTo.y, Math.abs(r), fullTheta);
//					dotSet([point, relativeTo, {}]);
//					drawLine(point.x, point.y, relativeTo.x, relativeTo.y)

					return {
						r: r,
						theta: fullTheta || 0,
						circleR: point.circleR,
						phi1: point.phi1,
						phi2: point.phi2
					}
				},
				polarToCartesian = function (point, relativeTo) {
					var result = {
						x: relativeTo.x + point.r*Math.cos(point.theta),
						y: relativeTo.y + point.r*Math.sin(point.theta),
						circleR: point.circleR,
						phi1: point.phi1,
						phi2: point.phi2
					}
					return result;
				},
				this.drawTiledHex = drawTiledHex;
				this.drawMetatron = drawMetatron;
				this.drawFlowerOfLife = drawFlowerOfLife;
				this.drawCrossedOct = drawFlowerOct;

				this.polygon = drawCustomPolygon;
				this.spiral = drawCustomSpiral;
				this.clear = clear;
				this.markers = markMiddleSpot;

				ctx.strokeStyle = "#FFF";
			},
			ui = function () {
				var regi = {
						onlyNumbers: /^\d+$/,
						onlyNumbersWithFractions: /^\d+(\.\d+)?$/,
					},
					shapeStack = [],
					exportShapeStack = [],
					lsStack = localStorage.getItem('stack'),
					$canvas = $('#canvas0'),
					$controls = $('#ui-controls-wrapper'),
					$stack = $('#ui-stack-wrapper'),
					$stack_empty = $stack.find('.ui-stack-empty'),
					$stack_block_controls = $stack.find('.ui-stack-block-controls'),
					$stack_block_controls_saveToLS = $stack_block_controls.find('.ui-stack-saveToLS'),
					$stack_block_wrapper = $stack.find('.ui-stack-block-wrapper'),
					$stack_block = $stack_block_wrapper.find('.ui-stack-block').remove(),
					$stack_clearStack = $stack.find('.tools-clearStack'),
					$stack_exportWrapper = $stack.find('.export-wrapper'),
					$stack_exportOutputInput = $stack_exportWrapper.find('textarea'),
					$step1_tools = $controls.find('.tools-wrapper'),
					$step1_tools_pushToStack = $step1_tools.find('.tools-pushToStack'),
					$step1_tools_markersSwitch = $step1_tools.find('#tools-markers'),
					$step1_tools_rotator_switchCheckbox = $step1_tools.find('#tools-rotator-checkbox'),
					$step1_tools_rotator_section = $step1_tools.find('.tools-rotator-angle, .rotation-axis-wrapper'),
					$step1_tools_rotator_angleInput = $step1_tools.find('.rotator-angle'),
					$step1_tools_rotator_axisRadios = $step1_tools.find('.tools-rotator-mode-radios'),
					$step1_tools_rotator_axisCMidpointRadio = $step1_tools_rotator_axisRadios.filter('#tools-rotator-axisCMid'),
					$step1_tools_rotator_axisSMidpointRadio = $step1_tools_rotator_axisRadios.filter('#tools-rotator-axisSMid'),
					$step1_tools_rotator_axisCustomRadio = $step1_tools_rotator_axisRadios.filter('#tools-rotator-axisCustom'),
					$step1_tools_rotator_axisCustomInputs = $step1_tools.find('.tools-rotator-customAxisInput'),
					$step1_tools_rotator_axisCustomXInput = $step1_tools_rotator_axisCustomInputs.filter('.tools-rotator-customAxisInputX'),
					$step1_tools_rotator_axisCustomYInput = $step1_tools_rotator_axisCustomInputs.filter('.tools-rotator-customAxisInputY'),
					$step1_coords = $controls.find('.coords-wrapper .coords-X, .coords-wrapper .coords-Y'),
					$step1_coordsX = $step1_coords.filter('.coords-X'),
					$step1_coordsY = $step1_coords.filter('.coords-Y'),
					$step1_radios = $controls.find("input[type=radio][name=step1-radio]"),
					$step1_radiosPolygon = $step1_radios.filter('#step1-radio1'),
					$step1_radiosSpiral = $step1_radios.filter('#step1-radio2'),
					$step2 = $controls.find('.step2'),
					$step2_sections = $step2.find('.step2-section'),
					$step2_polygon_inputs = $step2.find('.step2-polygon input'),
					$step2_polygon_edges = $step2_polygon_inputs.filter('.polygon-edges'),
					$step2_polygon_radius = $step2_polygon_inputs.filter('.polygon-radius'),
					$step2_spiral_ratio = $step2.find('.spiral-ratio-wrapper'),
					$step2_spiral_radios = $step2_spiral_ratio.find('input[type=radio][name=spiral-ratio-radio1]'),
					$step2_spiral_radiosGolden = $step2_spiral_radios.filter('#spiral-ratio-radio1'),
					$step2_spiral_radiosCustom = $step2_spiral_radios.filter('#spiral-ratio-radio2'),
					$step2_spiral_ratioCustom = $step2_spiral_ratio.find('.spiral-ratio-custom'),
					polygonNames = ['Nullagon', 'Monogon', 'Digon', 'Triangle', 'Quadrilateral', 'Pentagon', 'Hexagon', 'Heptagon', 'Octagon', 'Nonagon', 'Decagon', 'Hendecagon', 'Dodecagon'],
					ranges = {
						x: [0, 1000],
						y: [0, 1000],
						edges: [3, 20],
						radius: [1, 1000],
						ratio: [0.001, 0.9999],
						rotationAngle: [0, 1000*2*pi]
					},
					isValid = {
						polygon: function () {
							var isValid = $step1_radiosPolygon.is(':checked'),
								edges = $step2_polygon_edges.val(),
								radius = $step2_polygon_radius.val();

							if (!edges.match(regi.onlyNumbers) || +edges < ranges.edges[0] || +edges > ranges.edges[1]) {
								isValid = false;
								+edges && $step2_polygon_edges.addClass('bad');
							} else {
								$step2_polygon_edges.removeClass('bad');
							}
							if (!radius.match(regi.onlyNumbersWithFractions) || +radius < ranges.radius[0] || +radius > ranges.radius[1]) {
								isValid = false;
								+radius && $step2_polygon_radius.addClass('bad');
							} else {
								$step2_polygon_radius.removeClass('bad');
							}

							return isValid;
						},
						spiral: function () {
							var isValid = $step1_radiosSpiral.is(':checked'),
								customRatio = $step2_spiral_ratioCustom.val();

							if (isValid) {
								if ($step2_spiral_radiosCustom.is(':checked')) { // Second
									if (!customRatio.match(regi.onlyNumbersWithFractions) || +customRatio < ranges.ratio[0] || +customRatio > ranges.ratio[1]) {
										isValid = false;
										+customRatio && $step2_spiral_ratioCustom.addClass('bad');
									} else {
										+customRatio && $step2_spiral_ratioCustom.removeClass('bad');
									}
								} else if (!$step2_spiral_radiosGolden.is(':checked')) { // Neither
									isValid = false;
								}
							}
							return isValid;
						},
						coords: function () {
							var isValid = true, x = $step1_coordsX.val(), y = $step1_coordsY.val();

							if (!x.match(regi.onlyNumbers) || +x < ranges.x[0] || +x > ranges.x[1]) {
								isValid = false;
								+x && $step1_coordsX.addClass('bad');
							} else {
								$step1_coordsX.removeClass('bad');
							}
							if (!y.match(regi.onlyNumbers) || +y < ranges.y[0] || +y > ranges.y[1]) {
								isValid = false;
								+y && $step1_coordsY.addClass('bad');
							} else {
								$step1_coordsY.removeClass('bad');
							}

							return isValid;
						},
						rotate: function () {
							var isValid = $step1_tools_rotator_switchCheckbox.is(':checked'),
								angle = $step1_tools_rotator_angleInput.val(),
								x = $step1_tools_rotator_axisCustomXInput.val(),
								y = $step1_tools_rotator_axisCustomYInput.val();

							if (isValid) {
								if (!angle.match(regi.onlyNumbersWithFractions) || +angle < ranges.rotationAngle[0] || +angle > ranges.rotationAngle[1]) {
									isValid = false;
									+angle && $step1_tools_rotator_angleInput.addClass('bad');
								} else {
									$step1_tools_rotator_angleInput.removeClass('bad');
								}

								if ($step1_tools_rotator_axisCustomRadio.is(':checked')) {
								if (!x.match(regi.onlyNumbers) || +x < ranges.x[0] || +x > ranges.x[1]) {
									isValid = false;
									+x && $step1_tools_rotator_axisCustomXInput.addClass('bad');
								} else {
									$step1_tools_rotator_axisCustomXInput.removeClass('bad');
								}

								if (!y.match(regi.onlyNumbers) || +y < ranges.y[0] || +y > ranges.y[1]) {
									isValid = false;
									+y && $step1_tools_rotator_axisCustomYInput.addClass('bad');
								} else {
									$step1_tools_rotator_axisCustomYInput.removeClass('bad');
								}
							}
							}
							return isValid;
						}
					},
					getAxisPoint = function (shapeMidpointX, shapeMidpointY) {
						var result;

						if ($step1_tools_rotator_axisCustomRadio.is(':checked')) {
							result = {
								x: +$step1_tools_rotator_axisCustomXInput.val(),
								y: +$step1_tools_rotator_axisCustomYInput.val()
							}
						} else if ($step1_tools_rotator_axisCMidpointRadio.is(':checked')) {
							result = {
								x: $canvas.width()/2,
								y: $canvas.height()/2
							}
						} else if ($step1_tools_rotator_axisSMidpointRadio.is(':checked')) {
							result = {
								x: shapeMidpointX || null,
								y: shapeMidpointY || null
							}
						}

						return result;
					},
					upDown = function (e, range, customIncrement) {
						var inc = customIncrement || 1,
							min = range[0], max = range[1];
						// UP and DOWN arrows
						switch (e.keyCode) {
							case 38:
								if (this.value.match(regi.onlyNumbersWithFractions) && (+this.value + inc) <= max) {
									this.value = roundLight(+this.value + inc);
								}

								if ((+this.value + inc) > max) { // Up above Max (Will only fire if previous didn't)
									this.value = max;
								}
								break;
							case 40:
								if (this.value.match(regi.onlyNumbersWithFractions) && (+this.value - inc) >= min) {
									this.value = roundLight(+this.value - inc);
								}
								if ((+this.value - inc) < min) { // Down below Min
									this.value = min;
								}
								break;
						}
					},
					makeBlock = function (shapeIndex) {
						var content, result,
							shapeArr = exportShapeStack[shapeIndex],
							rotationObj;

						switch (shapeArr[0]) {
							case 'spiral':
								content = 'Spiral';
								content += ' [' + (shapeArr[3] === null ? 'GR' : shapeArr[3]) + ']';
								content += ' (' + shapeArr[1] + ',' + shapeArr[2] + ')';
								rotationObj = shapeArr[4];
								break;
							case 'polygon':
								content = (polygonNames[shapeArr[4]] || 'Polygon') + ' (' + shapeArr[4] + ')';
								content += ' R: ' + shapeArr[3];
								rotationObj = shapeArr[5];
								break;
						}

						if (rotationObj.rotate) {
							content += ' <' + rotationObj.theta + ': ';
							content += (rotationObj.axisPoint.x === null || rotationObj.axisPoint.y === null ? 'MidPoint' : (rotationObj.axisPoint.x + ', ' + rotationObj.axisPoint.y)) + '>';
						}

						content += ' (' + shapeArr[1] + ',' + shapeArr[2] + ')';

						result = $stack_block.clone()._show().html(content);
						result.append($('<button/>')
								.addClass('stack-delete')
								.text('X')
								.click(deleteFromStack.bind(null, shapeIndex))
						)

						return result;
					},
					deleteFromStack = function (i) {
						shapeStack.splice(i, 1);
						exportShapeStack.splice(i, 1);
						updateStackIndication();
						mainCanvas.clear();
						drawStack();
						$stack_block_controls_saveToLS.text('Save to LocalStorage *');
					},
					drawStack = function () {
						for (var i=0; i<shapeStack.length; i++) {
							shapeStack[i]();
						}
						if ($step1_tools_markersSwitch.is(':checked')) {
							mainCanvas.markers();
						}
					},
					updateStackIndication = function () {
						var index;

						$step1_tools_pushToStack.val('Save to Stack (' + exportShapeStack.length + ')');

						if (!exportShapeStack.length) {
							$stack_empty._show();
							$stack_block_wrapper._hide();
						} else {
							$stack_empty._hide();
							$stack_block_wrapper.html('');
							for (index=0; index<exportShapeStack.length; index++) {
								$stack_block_wrapper.append(makeBlock(index));
							}
							$stack_block_wrapper._show();
							$stack_block_controls._show();
						}
					},
					generatePolygon = function (e, store) {
						var edges, radius, x, y, rotationParams = {};
						setTimeout(function () { // To catch first value
							if (isValid.coords() && isValid.polygon()) {
								edges = +$step2_polygon_edges.val();
								radius = +$step2_polygon_radius.val();
								x = +$step1_coordsX.val();
								y = +$step1_coordsY.val();

								if (isValid.rotate()) { // Rotate!
									rotationParams = {
										rotate: true,
										theta: +$step1_tools_rotator_angleInput.val(),
										axisPoint: getAxisPoint(x, y)
									}
								}

								if (store) {
									shapeStack.push(mainCanvas.polygon.bind(mainCanvas, x, y, radius, edges, rotationParams));
									exportShapeStack.push(['polygon', x, y, radius, edges, rotationParams]);
									saveCurrentStackToLocalStorage();
									updateStackIndication();
								} else {
									mainCanvas.clear();
									drawStack();
									mainCanvas.polygon(x, y, radius, edges, rotationParams);
								}
							}
						}, 10)
					},
					storePolygon = generatePolygon.bind(null, null, true),
					generateSpiral = function (e, store) {
						var ratio = null, x, y, rotationParams = {};
						setTimeout(function () {
							if (isValid.coords() && isValid.spiral()) {
								if ($step2_spiral_radiosCustom.is(':checked')) {
									ratio = +$step2_spiral_ratioCustom.val();
								}
								x = +$step1_coordsX.val();
								y = +$step1_coordsY.val();

								if (isValid.rotate()) { // Rotate!
									rotationParams = {
										rotate: true,
										theta: +$step1_tools_rotator_angleInput.val(),
										axisPoint: getAxisPoint(null)
									}
								}

								if (store) {
									shapeStack.push(mainCanvas.spiral.bind(mainCanvas, x, y, ratio, rotationParams));
									exportShapeStack.push(['spiral', x, y, ratio, rotationParams]);
									saveCurrentStackToLocalStorage();
									updateStackIndication();
								} else {
									mainCanvas.clear();
									drawStack();
									mainCanvas.spiral(x, y, ratio, rotationParams);
								}
							}
						}, 0)
					},
					storeSpiral = generateSpiral.bind(null, null, true),
					roundLight = function (num) {
						var result = ("" + num).substr(0, 6);
						return +result;
					}
					functionifyExportStack = function () {
						shapeStack = exportShapeStack.map(function (shape) {
							var type = shape[0];							
							return mainCanvas[type].bind.apply(mainCanvas[type], [mainCanvas].concat(shape.slice(1)));
						})
					},
					makeUpDownFunction = function (range, customInc) {
						return function (e) {
							upDown.call(e.target, e, range, customInc);
						}
					},
					saveCurrentToStack = function () {
						var selected = $step1_radios.filter(':checked').val(),
								actions = {
									"step1-radio1": storePolygon,
									"step1-radio2": storeSpiral
								}

						if (actions[selected]) {
							actions[selected]();
						}
					},
					saveCurrentStackToLocalStorage = function () {
						localStorage.setItem('stack', JSON.stringify(exportShapeStack));
						$stack_block_controls_saveToLS.text('Save to LocalStorage');
					},
					importStack = function (stack) {
						exportShapeStack = JSON.parse(stack);
						functionifyExportStack();
						updateStackIndication();
						drawStack();
					},
					toggleRotationView = function () {
						$step1_tools_rotator_section._toggle($step1_tools_rotator_switchCheckbox.is(':checked'));
					},
					enhanceJQuery = function () {
						$.fn._hide = function () {
							$(this).addClass('hidden');
							return $(this);
						}
						$.fn._show = function () {
							$(this).removeClass('hidden');
							return $(this);
						}
						$.fn._toggle = function (flag) {
							flag ? this._show() : this._hide();
							return $(this);
						}
					};

				enhanceJQuery();

				// Step 1 //
				// First step radios
				$step1_radios.change(function () {
					var actions = {
						"step1-radio1": $step2_sections.filter('.step2-polygon'),
						"step1-radio2": $step2_sections.filter('.step2-spiral')
					}

					$step2_sections._hide();

					actions[this.value]._show.call(actions[this.value]);
				});
				// Bind up/downs
				$step1_coords
						.add($step1_tools_rotator_axisCustomInputs)
							.on("keydown", makeUpDownFunction(ranges.x, 10)); // Use x's for both, separatable tho
				$step2_polygon_edges.on("keydown", makeUpDownFunction(ranges.edges));
				$step2_polygon_radius.on("keydown", makeUpDownFunction(ranges.radius, 10));
				$step2_spiral_ratioCustom.on("keydown", makeUpDownFunction(ranges.ratio, 0.05));
				$step1_tools_rotator_angleInput.on("keydown", makeUpDownFunction(ranges.rotationAngle, 0.1));


				// Step 2 //
				// Polygon Edges and Radius
				$step2_polygon_inputs.on("keydown", generatePolygon);

				// Golden or Custom Radios and Custom input
				$step2_spiral_radios.add($step1_tools_rotator_switchCheckbox).change(generateSpiral);
				$step2_spiral_ratioCustom.on("keydown", generateSpiral);

				// Main shapes
				$step1_coords
						.add($step1_tools_rotator_angleInput)
						.add($step1_tools_rotator_axisCustomInputs)
							.on("keydown", generatePolygon)
							.on("keydown", generateSpiral);

				$step1_tools_rotator_axisRadios
						.change(generatePolygon)
						.change(generateSpiral)

				$step1_tools_rotator_switchCheckbox
						.change(toggleRotationView)
						.change(generatePolygon);

				$step1_tools_markersSwitch.change(function () {
					if ($(this).is(':checked')) {
						mainCanvas.markers();
					} else {
						mainCanvas.clear();
						drawStack();
						generatePolygon();
						generateSpiral();
					}
				})
				$step1_tools_pushToStack.click(saveCurrentToStack);

				$stack_clearStack.click(function () {
					exportShapeStack = [];
					shapeStack = [];
					updateStackIndication();
					mainCanvas.clear();
					$stack_block_controls_saveToLS.text('Save to LocalStorage *');
				})

				$stack_block_controls_saveToLS.click(saveCurrentStackToLocalStorage);

				// Last action, beginning of scope!
				if (lsStack) {
					importStack(lsStack);
				}

				$(document).keypress(function (e) {
					if (e.keyCode === 83 && e.shiftKey) { // S Push to Stack
						e.preventDefault();
						saveCurrentToStack();
					}

					if (e.keyCode === 73 && e.shiftKey) { // I Import
						var input = prompt('Please insert JSON instructions');
						try {
							importStack(input);
						} catch (err) {
							alert('Corrupt JSON, import failed');
						}
					}

					if (e.keyCode === 69 && e.shiftKey) { // E Export
						$stack_exportOutputInput.html(JSON.stringify(exportShapeStack))
						$stack_exportWrapper.fadeIn(800);
					}
				})

				this.getJSON = function () {
					console.log(JSON.stringify(exportShapeStack));
				}
			},
			mainCanvas = new geometryMaker("canvas0"),
			uiInstance = new ui();

    </script>
</body>

</html>